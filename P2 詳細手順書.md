# P2 詳細実装手順書 — 通知 (/notify)・期限削除・モデログ連携

> 目的：P1 で抽出した RED/ORANGE/YELLOW をモデレーターが迅速に処理できる状態へ仕上げる。\
> 現行 bot (`app/main.py`) には `/notify` コマンドと Embed レビュー UI が実装済み。P2 ではこれらを基盤に、**通知 → 期限監視 → 自動削除 → モデログ記録** を完成させる。

---

## 0) スコープと Done の定義

### 現行実装（main ブランチ時点）
- `/notify` Slash コマンド（guild only）: `app/main.py:522`。`channel_id` と `message_id` を引数に削除依頼を返信。Allowed Mentions は投稿者のみに限定。期限は `Settings.due_hours` (72h)。
- `/report format=embed` のエフェメラルビュー: `ReportPaginator` (`app/main.py:237`) が findings をページング表示。`Notify` ボタンは `/notify` ロジックを呼び出し、`Log` ボタンは #mod-bot-log へ Embed を再投稿。
- `/scan` `/report` のフィルタ（channel, since/until, severity, format）と設定 (`app/config.py`)。

### P2 で完了させる項目（今回決定した方針）
- `/notify` を **message_link 引数**で受け付けるよう改修し、内部で `guild/channel/message` を正規化。Embed ボタンからの呼び出しは既存の channel/message を利用。
- 通知レコードを **SQLite** に永続化し、ステータス・操作ログを管理。
- **自前 asyncio ループ** による期限監視タスクを追加（APScheduler は導入しない）。
- 期限到達時は `Message.delete` を実行し、**モデログには既存 Embed を再利用**して結果を投稿。
- 削除や失敗時の **Audit Log Reason は統一フォーマット**で送信。

---

## 1) 現行コードの把握とギャップ

* `send_notify_message` (`app/main.py:101`): 投稿メッセージを取得し、締切を JST で計算したテンプレートを返信。
* `_build_allowed_mentions` (`app/main.py:128`): 投稿者のみメンションする設定を生成。
* `ReportPaginator._message_targets` (`app/main.py:333`): findings JSON の `messages[0]` から `channel_id`/`message_id` を取得。欠落時は Notify ボタンを無効化。
* `ReportPaginator.on_log` (`app/main.py:481`): Embed を #mod-bot-log に転送し、Footer に操作者を追記。
* `/notify` Slash コマンド (`app/main.py:522`): 現状は `channel_id`/`message_id` を受け取る仕様。→ P2 で message_link へ変更し、Embed 側との互換レイヤーを用意する。

---

## 2) Slash コマンド / ボタン仕様

### `/notify`
```
/notify message_link:<string> [due_hours:int]
```
- Slash 引数は Discord のメッセージリンク (`https://discord.com/channels/...`) を受け取る。`message_link` を `parse_message_link()` ユーティリティ（新規実装）で `guild_id/channel_id/message_id` に分解。
- Link 解析失敗時はエフェメラルでエラーを返す。成功時は既存の `send_notify_message` を呼び出す。
- `/report` の `Notify` ボタンは `discord.ui.Button` の `custom_id`/`callback` で引き続き `channel_id`/`message_id` を渡し、Slash 側の仕様変更と共存させる。
- 期限計算は `hours = due_hours or settings.due_hours`。テンプレートは `app/notifier.py` へ切り出し済みの関数を流用。

### Embed ビュー（`/report format=embed`）
- エフェメラル配信、`timeout=600`。発行者以外の操作は拒否。
- ボタン構成は現状維持（◀/▶, Notify, Log, Open Message, Open Original）。`Notify` ボタン押下時は SQLite 連携が必要になるため、成功後に「通知済み」「既に通知済み」のフィードバックを返す。
- Log ボタンは #mod-bot-log へ Embed を再投稿。自動削除の結果共有もこの Embed 表現に合わせる。

---

## 3) 期限管理フロー（AsyncIO ループ）

1. Bot 起動時に `asyncio.create_task(start_ticket_watcher())` を呼び出し、バックグラウンドタスクとして登録。
2. `start_ticket_watcher()` は無限ループで、`await asyncio.sleep(settings.ticket_poll_interval)`（例: 300 秒）毎に期限チェックを実行。
3. チェック処理：SQLite から `status='notified'` かつ `due_at <= now` のレコードを取得。
4. 各チケットに対し `_fetch_message` でメッセージ取得 →
   - 取得不可（404）: `status='author_deleted'` に更新し、モデログへ「投稿者側で削除済み」と通知。
   - 取得成功: `message.delete(reason=build_audit_reason(ticket))` を実行。成功で `status='bot_deleted'`、失敗なら `status='failed'` とし、モデログにエラー詳細を含めて送信。
5. モデログ通知は既存 Embed をベースに、Footer や追加フィールドに「Action」「Result」「Due」等を追記。
6. タスクは `asyncio.CancelledError` を捕捉してクリーンに終了させる（`client.close()` 時など）。

---

## 4) データモデルとストレージ

### SQLite ファイル
- 既定パス: `data/modbot.db`（`.env` で `TICKET_DB_PATH` 上書き可能）。存在しなければ初期化時に作成。
- 接続: `aiosqlite` を利用し、アプリ起動時にシングルトン接続を確立。`get_db()` ヘルパで取得し、SQL 実行は `async with db.execute(...)` 形式で行う。

### テーブルスキーマ
```sql
CREATE TABLE IF NOT EXISTS tickets (
  ticket_id    TEXT PRIMARY KEY,
  guild_id     INTEGER NOT NULL,
  channel_id   INTEGER NOT NULL,
  message_id   INTEGER NOT NULL,
  author_id    INTEGER NOT NULL,
  severity     TEXT NOT NULL CHECK (severity IN ('red','orange','yellow','green')),
  rule_id      TEXT,
  reason       TEXT,
  message_link TEXT NOT NULL,
  due_at       TEXT NOT NULL,
  status       TEXT NOT NULL CHECK (status IN ('notified','author_deleted','bot_deleted','expired','dismissed','failed')),
  executor_id  INTEGER NOT NULL,
  created_at   TEXT NOT NULL,
  updated_at   TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS ticket_logs (
  id         INTEGER PRIMARY KEY AUTOINCREMENT,
  ticket_id  TEXT NOT NULL,
  actor_id   INTEGER NOT NULL,
  action     TEXT NOT NULL CHECK (action IN ('notify','auto_delete','auto_delete_failed','author_deleted','dismiss')),
  detail     TEXT,
  created_at TEXT NOT NULL
);
```
- `ticket_id`: `f"{guild_id}:{channel_id}:{message_id}"` で一意化。
- `/notify` 実行者は `executor_id` に保存（自動削除失敗時の通知対象にも使える）。
- `due_at` は ISO8601 (UTC) を使用し、比較前に `datetime.fromisoformat(...).astimezone(timezone.utc)` で統一。
- インデックス: `CREATE INDEX idx_tickets_due ON tickets(status, due_at);`

---

## 5) 実装ステップ詳細

1. **SQLite 初期化ユーティリティ**
   - `app/store.py` に `TicketStore` クラスを追加。`initialize()` でテーブル作成・インデックス構築。
   - `TicketStore.upsert_ticket(...)`, `fetch_due_tickets(now)`, `update_status(...)`, `append_log(...)` などの API を用意。

2. **/notify の改修**
   - `parse_message_link()` を util として実装し、Slash 引数を `int` 化。
   - 既存の `notify` ハンドラで `ticket_store.upsert_ticket(...)` を呼び、重複時は `status` を確認して「既に通知済み」と返す。
   - 成功時は `ticket_logs` に `notify` を追加。

3. **Embed Notify ボタンの連携**
   - ボタン押下時、SQLite に同じく upsert。Slash と同一ロジックを共用するため、`process_notify_request(guild_id, channel_id, message_id, executor)` のような関数に切り出す。
   - すでに通知済みの場合はエフェメラルで「既に通知済み（期限: ...）」と返す。

4. **期限監視タスク**
   - `app/main.py` 起動フローで `ticket_store.initialize()` → `asyncio.create_task(ticket_watcher(ticket_store, client, settings))`。
   - `ticket_watcher` は `while True` で `fetch_due_tickets()` を呼び出し、各チケットを処理後 `ticket_logs` を追加。
   - 成功時は `Log` ボタンと同じ Embed を組み立て、`settings.log_channel_id` へ送信。

5. **Audit Log Reason 統一**
   - `build_audit_reason(ticket, action)` を新設し、`f"ModBot {action}|rule={ticket.rule_id}|ticket={ticket.ticket_id}"` 形式で返す。
   - `send_notify_message` や `message.delete` でこのヘルパを利用。

6. **設定値拡張**
   - `Settings` に `ticket_db_path: Path = Path("data/modbot.db")`, `ticket_poll_interval: int = 300` を追加。`.env` から上書き可能にする。
   - 初期化時に `data/` ディレクトリを作成。

---

## 6) テスト指針

- **リンク解析テスト**: `parse_message_link()` の成功ケース/失敗ケースを網羅。
- **/notify ハンドラ**: Allowed Mentions の検証、チケット重複時のレスポンス、例外時のログ。
- **TicketStore**: SQLite の upsert、due 抽出、ステータス更新が期待通りか（`pytest` + `tmp_path` を利用）。
- **期限タスク**: `ticket_watcher` に対して `asyncio.advance_time` (`pytest-asyncio` の `autojump_clock` 等) を使い、
  - 自動削除成功→`bot_deleted` ステータスとモデログ投稿
  - 既に削除済み→`author_deleted`
  - 削除失敗（例: `Forbidden`）→`auto_delete_failed`
- **Embed ボタン**: `_message_targets` 欠落時の disabled、通知済み状態でのフィードバック。

---

## 7) 運用フロー

1. `/scan` で最新の findings を作成し、必要に応じて `post_summary=true` でモデログへ共有。
2. `/report format=embed` でレビューし、問題があれば `Notify` ボタンまたは `/notify message_link:` で通知。
3. Bot が SQLite を参照し期限を監視。期限到達で自動削除・モデログ投稿。失敗時は同モデログで詳細確認。
4. 定期的に `tickets` を確認し、`failed` や `dismiss` すべき項目を手動処理。

---

## 8) 補足・今後の検討事項

- SQLite バックアップの頻度と手順（例: 日次で `data/modbot.db` を退避）。
- `dismiss` や `manual_delete` といった人手オペレーションを Slash コマンド化するか。
- 長期的には通知テンプレートや期限時間をルールごとに可変にする拡張余地。

---

決定した方針（自前 asyncio ループ + SQLite + message_link + モデログ Embed 再利用 + Audit Log Reason 統一）を前提に、上記ステップで P2 実装を進める。
